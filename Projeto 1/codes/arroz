using BenchmarkTools

# Definição das variáveis
n_values = [10^4, 10^5, 10^6, 10^7]  # Tamanhos dos vetores
q_values = [10^2, 10^3, 10^4, 10^5]  # Quantidade de chaves

# Inicializar a matriz tridimensional
# Dimensões: (4 tamanhos de vetor) x (4 quantidades de chaves) x (número de chaves por vetor)
time_simple_search = Array{Float64}(undef, length(n_values), length(q_values), maximum(q_values))
time_to_sort = Vector{Float64}(undef, length(n_values))
time_optimized_search = Array{Float64}(undef, length(n_values), length(q_values), maximum(q_values))
time_binary_search = Array{Float64}(undef, length(n_values), length(q_values), maximum(q_values))

# Funções de busca e ordenação a serem usadas
function sequential_search(v, key)
    for element in v
        if element == key
            return true
        end
    end
    return false
end

function optimized_search(v, key)
    # Exemplo de uma busca otimizada, pode ser modificada conforme necessário
    return sequential_search(v, key)
end

function binary_search(v, key)
    # Supõe que v está ordenado
    low, high = 1, length(v)
    while low <= high
        mid = div(low + high, 2)
        if v[mid] == key
            return true
        elseif v[mid] < key
            low = mid + 1
        else
            high = mid - 1
        end
    end
    return false
end

# Inicialização das listas de vetores e chaves
vector_list = [generate_random_vector(10^n, 1000) for n in 4:7]
key_list = [generate_keys(10^q, 1000) for q in 2:5]

# Benchmarking da pesquisa linear simples
for i in 1:length(n_values)   # Para cada tamanho de vetor
    for j in 1:length(q_values)  # Para cada quantidade de chaves
        times = @benchmark begin
            for key in key_list[j]
                sequential_search(vector_list[i], key)
            end
        end
        for k in 1:length(key_list[j])
            time_simple_search[i, j, k] = minimum(times).time / 1e9  # Converter nanosegundos para segundos
        end
    end
end

# Benchmarking da ordenação dos vetores
for i in 1:length(n_values)   # Para cada tamanho de vetor
    times = @benchmark sort(vector_list[i])
    time_to_sort[i] = minimum(times).time / 1e9  # Converter nanosegundos para segundos
    vector_list[i] = sort(vector_list[i])  # Ordenar os vetores
end

# Benchmarking da busca otimizada
for i in 1:length(n_values)   # Para cada tamanho de vetor
    for j in 1:length(q_values)  # Para cada quantidade de chaves
        times = @benchmark begin
            for key in key_list[j]
                optimized_search(vector_list[i], key)
            end
        end
        for k in 1:length(key_list[j])
            time_optimized_search[i, j, k] = minimum(times).time / 1e9  # Converter nanosegundos para segundos
        end
    end
end

# Benchmarking da busca binária
for i in 1:length(n_values)   # Para cada tamanho de vetor
    for j in 1:length(q_values)  # Para cada quantidade de chaves
        times = @benchmark begin
            for key in key_list[j]
                binary_search(vector_list[i], key)
            end
        end
        for k in 1:length(key_list[j])
            time_binary_search[i, j, k] = minimum(times).time / 1e9  # Converter nanosegundos para segundos
        end
    end
end

# Mostrar os tempos
println("Tempos para pesquisa linear simples (em segundos):")
println(time_simple_search)

println("Tempos para ordenação (em segundos):")
println(time_to_sort)

println("Tempos para pesquisa otimizada (em segundos):")
println(time_optimized_search)

println("Tempos para pesquisa binária (em segundos):")
println(time_binary_search)
